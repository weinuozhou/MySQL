# 关系代数和关系数据库理论

## 引言

- 以**关系模型**为基础的关系数据库是目前应用较为广泛的数据库。
- 关系模型建立在**数学理论**的基础上。
- 关系数据库的**规范化理论**是数据库逻辑结构设计的理论指南。

## 关系模型及其定义

### 关系模型的基本要素

**关系模型**是数据库使用的一种典型数据模型。

在关系模型中，其数据结构为具有**一定特征的二维表**

- *候选码*(Candidate key): 若关系中的某一属性或属性组的值能**唯一地标识一个元组**，则称该属性或属性组为候选码(Candidate key)。
- *主码*(Primary key):若一个关系中有多个候选码，则选定其中一个为主码(也可以称为主键，主关键字)，当包含两个或更多个的键称为复合码(键)。
- *全码* (All-key):关系模式的**所有属性都是这个关系模式的候选码**，称为全码。
- *主属性*(Prime attribute)和非主属性(Non-prime attribute)在关系中，候选码中的属性称为主属性，不包含在任何候选码中的属性称为非主属性。
- *代理键*:是具有DBMS分配的唯一标识符，该标识符已经作为主键添加到表中。每次创建行时由DBMS分配代理键的唯一值，通常是较短的数字，该值永远不变。该值对于用户没有任何意义。

主码的作用:

- **标识唯一的行**，建立与别的表之间的联系
- 使用主码索引**快速检索**数据

数据库中关系的类型：

- **基本表**（基本关系或者基表）：实际存在的表，它是实际存储数据的逻辑表示
- **查询表**：查询结果表或查询中生成的临时表
- **视图表**：由基本表或其他视图表导出的表，是虚表，不对应实际存储的数据

### 关系模型的性质

1. 关系中的元组存储了某个实体或实体某个部分的数据
2. 关系中元组的位置具有**顺序无关性**，即元组的顺序可以任意交换
3. 同一属性的数据具有**同质性**，即每一列中的分量是同一类型的数据，它们来自同一个域
4. 同一关系的字段名具有**不可重复性**，即同一关系中不同属性的数据可出自同一个域，但不同的属性要给予不同的字段名
5. 关系具有**元组无冗余性**，即关系中的任意两个元组不能完全相同
6. 关系中列的位置具有**顺序无关性**，即列的次序可以任意交换、重新组织
7. 关系中**每个分量必须取原子值**，即每个分量都必须是不可分的数据项

### 关系操作

关系操作的三大功能:

- **数据查询**:数据检索、统计、排序、分组以及用户对信息的需求
- **数据维护**:数据添加、删除、修改等功能
- **数据控制**:保证数据的安全性和完整性

关系操作的**数据查询**和**数据维护**功能使用关系代数中的8种操作来表示，即并(Union)、差(Difference)、交(Intersection)、广义的笛卡儿积(Extended Cartesian Product)、选择(Select)、投影(Project)、连接(Join)和除(Divide)

其中选择、投影、并、差、笛卡尔积是5种基本操作。其他操作可以由基本操作导出

#### 关系操作语言的类型

- **关系代数语言**:用关系的运算来表达查询要求的方式
- **关系演算语言**:用查询得到的元组应满足的谓词条件来表达查询要求的语言
- 具有关系代数和关系演算双重特点的语言:**结构化查询语言**(SQL)，介于关系代数和关系演算之间的语言，它包括数据定义、数据操作和数据控制三种功能

#### 关系的完整性

- **实体完整性**:主属性不能取空值
    - 若属性A是基本关系R的主属性，则属性A不能取空值
- **参照完整性**:外码必须取空值或者另一个关系的主码值
    - 若属性(或属性组)F是基本关系R的外码，它与基本关系S的主码Ks相对应(基本关系R和S有可能是同一关系)，则对于R中每个元组在F上的值必须为以下值之一：
        - 取空值(F的每个属性值均为空值)
        - 等于S中某个元组的主码值
- **用户自定义的完整性**

## 关系代数及其运算

* 关系代数是一种抽象的**查询语言**
* 关系代数是建立在**集合代数**的基础上

关系数据结构的形式化定义:

* 域（Domain）
* 笛卡尔积（Cartesian Product）
* 关系（Relation）

### 域

* 域是一组具有相同数据类型值的集合
* 在关系模型中，使用域来表示**实体属性的取值范围**

### 笛卡儿积(Cartesian Product)

给定一组域D1，D2，…，Dn，这些域中可以有相同的值，也可以有不同的值，则可以定义一个n元组的集合，该集合由**所有域的所有取值的一个组合**组成，这个集合称为 n 元组的笛卡尔积

例如: 

* 姓名集合：D1={史丹妮，周冬元，李晓辉}
* 性别集合：D2={男，女}
* 专业集合：D3={会计，商务}

笛卡尔积的结果: $D_1\times D_2\times D_3$＝{（史丹妮，男，会计），（史丹妮，男，商务），（史丹妮，女，会计），（史丹妮，女，商务），（周冬元，男，会计），（周冬元，男，商务），（周冬元，女，会计），（周冬元，女商务），（李晓辉，男，会计），（李晓辉，男，商务），（李晓辉，女，会计），（李晓辉，女，商务）}

### 关系

关系为**多个域的笛卡尔乘积的有限子集**

### 关系代数概述

运算的三大要素:*运算对象*，*运算符*和*运算结果*

关系代数和运算对象是关系，运算结果也是关系

关系代数中使用的运算符有以下几种:

- 集合运算符
- 专门的关系运算符
- 比较运算符
- 逻辑运算符

#### 运算符

<div style="text-align: center;"><img alt='202403262107083' src='https://cdn.jsdelivr.net/gh/weno861/image/img/202403262107083.png' width=500px> </div>

传统的集合运算是二目运算，包括并，交，差，广义笛卡尔积四种运算
专门的关系运算包括选择、投影、连接、除四种运算

## 数据库设计的规范化

设计数据库要考虑减少**冗余数据**和**避免数据经常发生变化**，减少额外的维护

!> 规范化: 用形式更为简洁、结构更加规范的关系模式取代原有关系模式的过程。关系模式必须满足一定的完整性约束条件以达到现实世界对数据的要求

!> 完整性约束条件: 对属性取值范围的限定, 属性值间的相互联系(主要体现在值的相等与否)，这种联系称为数据依赖

### 依赖

指通过一个关系中属性间值的相等与否体现出来的数据间的相互关系

依赖的分类:

* 函数依赖
* 多值依赖
* 连接依赖

#### 函数依赖

设有关系模式$R(A_1，A_2，…，A_n)$或简记为$R(U)$，$X$，$Y$是$U$的子集，$r$是$R$的任一具体关系，如果对$r$的任意两个元组$t_1$，$t_2$，由$t_1[X]＝t_2[X]$导致$t_1[Y]=t_2[Y]$，则称$X$函数决定$Y$，或$Y$函数依赖于$X$，记为$X\to Y$

函数依赖不是指关系模式R的**某个或某些关系实例**满足的约束条件，而是指R的**所有关系实例**均要满足的约束条件

* $X\to Y$，但$Y\nsubseteq X$，则称$X\to Y$是**非平凡的函数依赖**
* $X\to Y$，但$Y\subseteq X$，则称$X\to Y$是**平凡的函数依赖**
* 在关系模式$R(U)$中，如果$X\to Y$，并且对于$X$的任何一个真子集$X_i$，都有$X_i\nrightarrow Y$，则称$Y$对$X$**完全函数依赖**
* 若$X\to Y$，如果存在X的某一真子集$X_i$，使$X_i\to Y$，则称$Y$ 对 $X$ **部分函数依赖**
* 在关系模式 $R(U)$中，$X$、$Y$、$Z$ 是 $R$ 的 $3$ 个不同的属性或属性组，如果 $X\to Y$($Y\nsubseteq X$，$Y$ 不是 $X$ 的子集)，且 $Y\nrightarrow X$，$Y\to Z$，$Z\notin Y$.则称 $Z$ 对$X$传递函数依赖

### 函数依赖的规范化过程

#### 第一范式

若一个关系模式R的所有属性都是**不可分的基本数据项**，则该关系属于第一范式(1NF)， 俗称**表中无表**

#### 第二范式

若关系模式R属于1NF，且R中**每个非主属性都完全函数依赖于主关键字**，则R属于第二范式

#### 第三范式

若关系模式R属于2NF，且**每个非主属性都不传递函数依赖于任何候选码**，则R属于第三范式

#### BCNF

关系模式 $R(U，F)\in 1NF$，若 $X\to Y$ 且 $Y\nrightarrow X$ 时，$X$ 必含有码，则 $R(U，F)\in BCNF$,也就是说，关系模式 $R(U，F)$中，若每个决定因素都包含码，则 $R(U，F)\in BCNF$

一个满足 BCNF 的关系模式有：

1. 所有非主属性对每一个码都是完全函数依赖
2. 所有的主属性对每一个不包含它的码，也是完全函数依赖
3. 没有任何属性完全函数依赖于非码的任何一组属性

### 关系模式规范化的基本步骤

$$1NF\rightarrow 2NF$$ |消除非主属性对码的部分函数依赖
:---|---
$$2NF\rightarrow 3NF$$ |消除非主属性对码的传递函数依赖
$$3NF\rightarrow BCNF$$ |消除非主属性对码的部分传递函数依赖
$$BCNF\rightarrow 4NF$$ |消除非平凡且非函数依赖的多值依赖
$$4NF\rightarrow 5NF$$ |消除不是由候选码所隐含的连接依赖

<div style="text-align: center;"><img alt='202403262131659' src='https://cdn.jsdelivr.net/gh/weno861/image/img/202403262131659.png' width=500px> </div>
