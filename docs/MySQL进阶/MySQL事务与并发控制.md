# MySQL 事务与并发控制

数据库与文件系统在数据管理优势在于**数据库实现了数据的一致性以及并发性**。对于数据库管理系统而言, **事务与锁**是实现数据一致性与并发性的基石

## MySQL的并发控制

> [!NOTE]
> * 在单处理机系统中, 事务的并行执行实际上是这些并行事务轮流交叉进行, 这种并行执行方式称为交叉并发方式
> * 在多处理机系统中, 每个处理机可以运行一个事务, 多个处理机可以同时运行多个事务, 实现事务真正的并发运行, 这种并发执行方式称为同时并发方式

### 并发

当**多个用户并发地存取数据库**时就会产生**多个事务同时存取同一数据**的情况。若对并发操作不加控制可能会存取和存储不正确的数据, 就会出现数据的不一致问题

> [!NOTE]
> 丢失更新(lost update) 问题

> 当两个或多个事务选择同一行, 然后基于最初选定的值更新该行时, 由于每个事务都不知道其他事务的存在, 就会发生丢失更新问题,  最后的更新覆盖了由其他事务所做的更新

> [!NOTE]
> 脏读(dirty read)问题

> 一个事务正在对一条记录做修改, 在这个事务完成并提交前, 这条记录的数据就处于不一致状态；这时, 另一个事务也来读取同一条记录, 如果不加控制, 第二个事务读取了这些脏数据, 并据此做进一步的处理, 就会产生未交的数据依赖关系, 这种现象被形象地叫作脏读

> [!NOTE]
> 不可重复读( unrepeatableread) 问题

> 当一个事务多次访问同一行而且每次读取不同的数据时, 会发生不可重复读( unrepeatableread)问题。当一个事务访问数据时, 另外的事务也访问该数据并对其进行修改, 因此就发生了由于第二个事务对数据的修改而导致第一个事务两次读到的数据不一样的情况, 这就是不可重复读

> [!NOTE]
> 幻读(phantom read) 问题

> 当一个事务对某行执行插入或删除操作, 而该行属于某个事务正在读取的行的范围时, 会发生幻读(phantom read)问题。事务第一次读的行范围显示出其中一行已不复存在于第二次读或后续读中, 因为该行已被其他事务删除

### 锁

当用户对数据库并发访问时, 为了确保**事务完整性和数据库一致性**, 需要使用锁定, 它是**实现数据库并发控制的主要手段**。锁定可以防止用户读取正在由其他用户更改的数据, 并可以防止多个用户同时更改相同数据, MySQL一般有三种锁:

* 表级锁
    * 一个特殊类型的访问, **整个表被客户锁定**。根据锁定的类型, 其他客户不能向表中插入记录, 甚至从中读数据也受到限制。其特点是：**开销小, 加锁快；不会出现死锁；锁定力度大, 发生锁冲突的概率最高, 并发度最低**
* 行级锁
    * 行级锁比表级锁或页面锁对锁定过程提供了更精细的控制。在这种情况下, 只有线程使用的行是被锁定的。表中的其他行对于其他线程都是可用的。其特点是：**开销大, 加锁慢；会出现死锁；锁定力度最小, 发生锁冲突的概率最低, 并发度也最高**
* 页面锁
    * MySQL将**锁定表中的某些行称为页**。被锁定的行只对锁定最初的线程是可行的。如果另外一个线程想要向这些行写数据, 它必须等到锁被释放。不过, 其他页的行仍然可以使用。其特点是：**开销和加锁时间界于表级锁和行级锁之间；会出现死锁；锁定力度界于表级锁和行级锁之间, 并发度一般**

### `MyISAM` 表的表级锁

`MyISAM` 在执行查询语句( `select` )前, 会自动给涉及的所有表加读锁, 在执行更新操作（ `update` 、 `delete` 、 `insert` 等）前, 会**自动给涉及的表加写锁**, 这个过程并不需要用户干预, 因此, 用户一般不需要直接用 `lock tables` 命令给 `MyISAM` 表显示加锁

`MySQL` 表级锁的锁模式:
* 表共享读锁(table read lock): 不会阻塞其他用户对同一表的读请求，但会阻塞对同一表的写请求
  * `lock table table_name read`
* 表独占写锁(table write Lock): 会阻塞其他用户对同一表的读和写操作
  * `lock table table_name write`


在对一个事务表使用表锁定的时候需要注意以下两点:

> [!NOTE]
> * 在锁定表时会**隐式地提交所有事务**, 在开始一个事务时, 如 `start transaction` , 会**隐式解开所有表锁定**
> * 在事务表中, 系统变量 `autocommit` 值必须设为0。否则,  `MySQL` 会在调用 `lock tables` 之后立刻释放表锁定, 并且很容易形成死锁

### `InnoDB` 表的行级锁

`InnoDB` 与 `MyISAM` 的最大不同有两点:
* 支持事务(transaction )
* 采用行级锁

> [!TIP]
> 获取InnoDB行锁争用情况

可以通过检查 `InnoDB_row_lock` 状态变量来分析系统上的行锁的争用情况

> [!TIP]
> `InnoDB` 行级锁的加锁方法

`InnoDB` 行锁是通过给索引上的索引项加锁来实现的,  这一点 `MySQL` 与 `Oracle` 不同, 后者是通过在数据块中对相应数据行加锁来实现的

> [!TIP]
> `InnoDB` 的行级锁的锁模式

* **共享锁\(S\)**: 允许一个事务去读一行, 阻止其他事务获得相同数据集的排他锁
    ```sql
    select * from table_name where … lock in share mode
    ```
* **排他锁(X)**: 允许获得排他事务更新数据, 阻止其他事务取得相同数据集的共享读锁和排他写锁
    ```sql
    select * from table_name where … for update
    ```

### 死锁

如果事务$T_1$封锁了数据$R_1$,  $T_2$封锁了数据$R_2$, 然后$T_1$又请求封锁$R_2$,  因$T_2$已封锁了$R_2$, 于是$T_1$等待$T_2$释放$R_2$上的锁。接着$T_2$又申请封锁$R_1$, 因$T_1$己封锁了 $R_1$ ,  $R_1$ 也只能等待$T_1$释放$R_1$上的锁。这样就出现了$T_1$在等待$T_2$, 而$T_2$又在等待$T_1$的局面,  $T_1$和$T_2$两个事务永远不能结束, 形成死锁

!> 如何避免死锁?

* 在应用中, 如果不同的程序会并发存取多个表, 应尽量约定**以相同的顺序来访表**, 这样可以大大降低产生死锁的机会
* 在程序以批量方式处理数据的时候, 如果**事先对数据排序**, 保证每个线程按固定的顺序来处理记录, 也可以大大降低出现死锁的可能
* 在事务中, 如果要更新记录, 应该直接**申请足够级别的锁**, 即排他锁, 而不应先申请共享锁, 更新时再申请排他锁
* 在 `repeatabie-read` 隔离级别下, 如果两个线程同时对相同条件记录用 `select...for update` 加排他锁, 在没有符合该条件记录情况下, 两个线程都会加锁成功。程序发现记录尚不存在, 就试图插入一条新记录, 如果两个线程都这么做就会出现死锁。这种情况下, 将隔离级别改成 `read committed` , 就可避免问题 
* 当隔离级别为 `read committed` 时,  如果两个线程都先执行 `select..for update` , 判断是否存在符合条件的记录, 如果没有, 就插入记录。此时, 只有一个线程能插入成功, 另一个线程会出现锁等待, 当第1个线程提交后, 第2个线程会因主键重出错,  虽然这个线程出错了, 却会获得一个排他锁, 这时如果有	第3个线程又来申请排他锁, 也会出现死锁

## 事务

事务用来管理 `DDL、DML、DCL` 操作，比如 `insert`,`update`,`delete` 语句，默认是自动提交的

### 事务的概念

事务通常包含一系列**更新操作**（ `update` 、 `insert` 和 `delete` 等操作语句）, 这些更新操作是一个**不可分割的逻辑工作单元**

如果事务成功执行, 那么该事务等中**所有的更新操作**都会**成功执行**, 并将执行结果提交到数据库文件中, 成为数据库永久的组成部分。如果事务中某个更新操作执行失败, 那么事务中的**所有更新操作均被撤销**, 所有影响到的数据将返回到事务开始以前的状态

<div style="text-align: center;"><img alt='202403311639421' src='https://cdn.jsdelivr.net/gh/weno861/image@main/img/202403311639421.png' width=500px> </div>

### 事务的 `ACID` 特性

* 原子性（A）
    * 原子性意味着每个事务都必须被认为是一个**不可分割的单元**。假设一个事务由两个或者多个任务组成, 其中的语句**必须同时成功**才能认为事务是成功的。如果事务失败, 系统将会返回到事务以前的状态
* 一致性（C）
    * 不管事务是完全成功完成还是中途失败, **当事务使系统处于一致的状态时存在一致性**
    * 在MySQL中, 一致性主要由MySQL的日志机制处理, 它记录了数据库的所有变化, 为事务恢复提供了跟踪记录。如果系统在事务处理中间发生错误, MySQL恢复过程将使用这些日志来发现事务是否已经完全成功地执行, 是否需要返回。因而一致性属性保证了数据库从不返回一个未处理完的事务
* 隔离性（I）
    * 隔离性是指每个事务在**它自己的空间发生, 和其他发生在系统中的事务隔离**, 而且事务的结果只有在它完全被执行时才能看到。即使在这样的一个系统中同时发生了多个事务, 隔离性原则保证某个特定事务在完全完成之前, 其结果是看不见的
* 持久性（D）
    * 持久性是指**即使系统崩溃, 一个提交的事务仍然存在**。当一个事务完成, 数据库的日志已经被更新时, 持久性就开始发生作用

### MySQL事务控制语句

`MySQL` 中可以使用 `begin` 开始事务, 使用 `commint` 结束事务, 中间可以使用 `rollback` 回滚事务。 `MySQL` 通过 `set autocommint` 、`start transaction` 、 `commit` 和 `rollback` 等语句支持本地事务

```sql
start transaction | begin [work]                                                                 
commit [work] [and [no] chain] [[no] release]                                                                 
rollback [work] [and [no] chain] [[no] release]                                                                 
set autocommit = {0 | 1} 
```

!> 所有SQL操作其实也有事务，只是 `MySQL` 自动帮我们完成的，每执行一条SQL时 `MySQL` 就帮我们自动提交事务，因此如果想要手动控制事务，则必须关闭 `MySQL` 的事务自动提交

```sql
set autocommit=0 禁止自动提交 
set autocommit=1 开启自动提交
```

> [!NOTE]
> 默认情况下, mysql 是 autocommit 的, 如果需要通过明确的commit和rollback来提交和回滚事务, 那么需要通过事务控制命令来控制

> [!TIP]
> * `start transaction`  或 `begin` 语句可以开始一项新的事务
> * `commit` 和 `rollback` 用来提交或者回滚事务
> * `set autocommit` 可以修改当前连接的提交方式, 如果设置了 `set autocommit=0`, 则设置之后的所有事务都需要通过明确的命令进行提交或者回滚

### 事务的隔离性级别

每一个事务都有一个所谓的隔离级, 它定义了**用户彼此之间隔离和交互的程度**, MySQL提供了下面4种隔离级:

* 序列化（`serializable`）
* 可重复读(`repeatable read`)
* 提交读(`read committed`)
* 未提交读（`read uncommitted`）

MySQL默认为 `repeatable read` 隔离级, 这个隔离级适用于大多数应用程序, 只有在应用程序有具体的对于更高或更低隔离级的要求时才需要改动

查看事务的隔离级别: `show variables like '%isolation%'; `

#### 序列化

```sql
set [global|session] transaction isolation level  serializable
```

> [!TIP]
> 如果隔离级为序列化, 用户之间通过一个接一个顺序地执行当前的事务提供了事务之间最大限度的隔离

#### 可重复读

```sql
set [global|session] transaction isolation level repeatable read
```

> [!TIP]
> 在这一级上, 事务不会被看成是一个序列。不过, 当前在执行事务的变化仍然不能看到, 也就是说, 如果用户在同一个事务中执行同条select语句数次, 结果总是相同的

#### 提交读

```sql
set [global|session] transaction isolation level read committed
```

> [!TIP]
> read committed隔离级的安全性比repeatable read隔离级的安全性要差。不仅处于这一级的事务可以看到其他事务添加的新记录, 而且其他事务对现存记录做出的修改一旦被提交, 也可以看到

#### 未提交读

```sql
set [global|session] transaction isolation level read uncommitted
```

> [!TIP]
> 提供了事务之间最小限度的隔离。除了容易产生虚幻的读操作和不能重复的读操作外, 处于这个隔离级的事务可以读到其他事务还没有提交的数据

<div style="text-align: center;"><img alt='202403311642005' src='https://cdn.jsdelivr.net/gh/weno861/image@main/img/202403311642005.png' width=500px> </div>















